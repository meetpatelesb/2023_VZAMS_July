#!/usr/bin/env node

var sys = require('sys'),
    fs = require('fs'),
    exec = require('child_process').exec,
    asyncMod = require('./asyncMod').asyncMod
    ;
/**/

var logFilePath = '/var/log/sgSay/runs/';

var Response = function(date_etc, bsid, method, href, body, result)
{
  var firstItems = date_etc.split(' ');
  this.time = firstItems[0];
  this.pid = firstItems[1];
  this.msgId = firstItems[2];
  this.mod = firstItems[3];
  
  this.bsid = bsid;
  this.method = method;
  this.href = href;
  this.body = body;
  this.result = eval(result);
}

var Session = function(response)
{
  this.responses = [];
  this.hrefs = {};
  if (response) {
    this.pushResponse(response);
  }
}

Session.prototype.pushResponse = function(response)
{
  this.responses.push(response);
  this.hrefs[response.href] = response;
}

Session.prototype.href = function(href)
{
  if (href instanceof RegExp) {
    var found = null;
    forEach(this.hrefs, function(item, index) {
      if (href.exec(index)) {
        found = item;
      }
    });
    return found;
  }
  else {
    return this.hrefs[href];
  }
}

var Sessions = function(response)
{
  this.EndedState = 'ended';
  this.EmptyState = 'empty';
  this.AccumState = 'accumulating';
  this.state = this.EmptyState;
  
  this.sessions = [];
  if (response)
    pushResponse(response);
}

Sessions.prototype.currentSession = function()
{
  return this.sessions[this.sessions.length - 1];
}

Sessions.prototype.pushResponse = function(response)
{
  // Create a new session?
  if (this.state != this.AccumState) {
    this.sessions.push(new Session(response));
    this.state = this.AccumState;
  }
  else {
    // Put the response into the current session
    this.currentSession().pushResponse(response);
  }
}

Sessions.prototype.endSession = function()
{
  this.state = this.EndedState;
}

function report(responses, a, b)
{
  var deltas = [];
  var aTime = 0;
  forEach(responses, function(r) {
    if (r.href === a) {
      aTime = r.time;
    } else if (r.href === b) {
      deltas.push(r.time - aTime);
    }
  });
  return deltas;
}

var LogFileStreamer = function(callback)
{
  var This = this;
  this.handlers = [];
  this.eventHandlers = [];
  
  this.init = function(callback)
  {
    exec('ls ' + logFilePath, function(err, lsStdout, lsStderr) {
      var ls = lsStdout.split('\n');
      var folderNum = -1;
      for (var i = 0; i < ls.length; i++) {
        var f = Number(ls[i]);
        if (f > folderNum)
          folderNum = f;
      }
      var folder = logFilePath + folderNum;
      exec('ls ' + folder, function(err, lsStdout, lsStderr) {
        var file = folder + '/' + lsStdout.split('\n')[0];
        fs.readFile(file, 'utf8', function(err, raw_contents) {
          This.contents = raw_contents.split('\n');
          callback();
        });
      });
    });
  }
  
  asyncMod.call(this, callback);
}

LogFileStreamer.prototype.on = function(re, fn)
{
  var handler = {re:re, fn:fn};
  var m;
  if (m = /SESSION-(.*)/.exec(re)) {
    this.eventHandlers[m[1]] = handler;   // Note: re is the event name, like 'end'
  }
  else {
    this.handlers.push(handler);
  }
}

LogFileStreamer.prototype.stream = function(callback)
{
  var This = this;
  
  var responses = {};
  forEach(This.contents, function(line) {
    forEach(This.handlers, function(handler) {
      if (handler.re.exec(line)) {
        handler.fn(line);
      }
    });
  });
  
  if (typeof callback === 'function')
    callback(null, this);
}

var RequestStreamer = function(logFileStreamer)
{
  var This = this;
  
  this.logFileStreamer = logFileStreamer;
  this.handlers = [];
  this.eventHandlers = {};
  this.sessions = {};
  
  this.seenUrls = {};

  logFileStreamer.on(/ 488 sg/, function(line) 
  {
    var parts = line.split(',, ');
    var response = construct(Response, parts);
    var workingSessions = null;
    if (!(response.bsid in This.sessions)) {
      This.sessions[response.bsid] = workingSessions = new Sessions();
    } else {
      workingSessions = This.sessions[response.bsid];
      
      // Is this a response that will start a new session?
      if (/sg...\/api\/approot/.exec(response.href)) {
        workingSessions.endSession();
        forEach(This.eventHandlers, function(handler) {
          if (handler.re === 'end') {
            handler.fn(response, This.currentSession(response.bsid));
          }
        });
      }
    }
    
    This._dispatch(response);
    workingSessions.pushResponse(response);
    if (!(response.href in This.seenUrls)) {
      This.seenUrls[response.href] = true;
    }
  });

  logFileStreamer.on(/ 487 sg/, function(line) 
  {
    var parts = line.split(',, ');
    var response = construct(Response, parts);
    var workingSessions = null;
    if (!(response.bsid in This.sessions)) {
      This.sessions[response.bsid] = workingSessions = new Sessions();
    } else {
      workingSessions = This.sessions[response.bsid];
      
      // Is this a response that will start a new session?
      if (/index\.html/.exec(response.href)) {
        workingSessions.endSession();
        forEach(This.eventHandlers, function(handler) {
          if (handler.re === 'end') {
            handler.fn(response, This.currentSession(response.bsid));
          }
        });
      }
    }
    
    This._dispatch(response);
    workingSessions.pushResponse(response);
    if (!(response.href in This.seenUrls)) {
      This.seenUrls[response.href] = true;
    }
  });
}

RequestStreamer.prototype.currentSession = function(bsid)
{
  return this.sessions[bsid].currentSession();
}

RequestStreamer.prototype.on = function(field, re, fn)
{
  var handler = {field:field, re:re, fn:fn};
  if (field === 'SESSION') {
    this.eventHandlers[re] = handler;   // Note: re is the event name, like 'end'
  }
  else {
    this.handlers.push(handler);
  }
}

RequestStreamer.prototype._dispatch = function(response)
{
  var This = this;
  forEach(this.handlers, function(handler) {
    if (handler.re.exec(response[handler.field])) {
      handler.fn(response, This.currentSession(response.bsid));
    }
  });
  
}

RequestStreamer.prototype.stream = function(callback)
{
  var This = this;
  this.logFileStreamer.stream(function(err) {
    forEach(This.eventHandlers, function(handler) {
      if (handler.re === 'end')
        forEach(This.sessions, function(sessions, key) {
          handler.fn(null, sessions.currentSession());
        });
    });
    callback(err);
  });
}

/*main()*/
if (__filename === process.argv[1])
{
  var lfs = new LogFileStreamer(function(err, lfs) {
    var s = new RequestStreamer(lfs);
    
    s.on('SESSION', 'end', function(req, session) {
      var start = session.href(/approot/);
      if (!start)
        start = session.href(/index\.html/);
      if (start) {
      
        var submitPurchaseTime = 0;
        var submitPurchase = session.href(/submit-purchase/);
        if (submitPurchase) {
          submitPurchaseTime = (submitPurchase.time - start.time) / 1000.0;
//          sys.puts('Time to purchase: ' + (submitPurchaseTime/1000.0) + ' sec.');
        }
        else {
//          sys.puts('No purchase in ' + ((new Date() - start.time)/1000.0) + ' sec.');
        }
        
        var placeOrderTime = 0;
        var placeOrder = session.href(/placeOrder/);
        if (placeOrder) {
          placeOrderTime = (placeOrder.time - start.time) / 1000.0;
//          sys.puts('Time to purchase: ' + (placeOrderTime/1000.0) + ' sec.');
        }
        else {
//          sys.puts('No placeOrder in ' + ((new Date() - start.time)/1000.0) + ' sec.');
        }
        
        sys.puts('Send info: ' + submitPurchaseTime + ' sec.  Place order: ' + placeOrderTime + ' sec.');
      }
    });
    
    s.on('mod', /sg/, function(req, session) {
//      sys.puts(req.href);
    });
    
    s.stream(function(err) {
//      sys.puts(keys(s.seenUrls).join('\n'));
    });
  });
}

function construct(ctor, args)
{
  function F() {
    return ctor.apply(this, args);
  }
  F.prototype = ctor.prototype;
  return new F();
}

var forEach = function(a, callback)
{
  if ('length' in a) {
    for (var i = 0; i < a.length; i++) {
      callback(a[i], i, a);
    }
  } else {
    for (var k in a) {
      callback(a[k], k, a);
    }
  }
}

var keys = function(d)
{
  var ret = [];
  forEach(d, function(x,k) {
    ret.push(k);
  });
  return ret;
}
