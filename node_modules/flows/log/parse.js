
var sys = require('sys'),
    exec = require('child_process').exec,
    spawn = require('child_process').spawn,
    urlParse = require('url'),
    asyncMod = require('./asyncMod').asyncMod,
    querystring = require('querystring')
    ;
var fs=require('fs');//@flow
function say(id)
{
  if (id !== 999)
    return;
   
  var puts = sys.puts;
  if (id === 999)
    puts = sys.print;
  sys.print('LogFileParser (' + id + ')');
  var args = Array.prototype.slice.call(arguments, 1);
  args.forEach(function(arg) {
    sys.print(sys.inspect(arg, false, null));
    puts(',');
  });
}

function say2(id)
{
  var puts = sys.puts;
  if (id > 999) {
    id -= 1000;
    puts = sys.print;
  }
  sys.print('LogFileParser (' + id + ')');
  var args = Array.prototype.slice.call(arguments, 1);
  args.forEach(function(arg) {
    sys.print(sys.inspect(arg, false, null));
    puts(',');
  });
}

function noop(){}

/**@ignore*/
var dt = exports.dt = function(obj, t)
{
  return (obj.header.time - t);
}

var parseLine = function(line)
{
  var fields = line.split(',, '),
      head = fields.shift().split(' '),
      ret = {header:{time:head[0], pid:head[1], id:head[2], mod:head[3]}};
  
  var obj = null;
  fields.forEach(function(field) {
    try {
      if (field[0] == '[' || field[0] == '{') {
        eval('obj=' + field);
      }
      else {
        obj = field;
      }
    }
    catch(err) {
      obj = {merticsParseError:err};
    }
    Array.prototype.push.call(ret, obj);
  });
  
  return ret;
}

var LogFilesStreamer = function(filenames_, ctor_callback)
{
  var This = this,
      filenames = filenames_;
  
  this.init = function(callback)
  {
    callback(null, this);
  }
  
  this.handlers = [];
  this._on = function(spec, callback)
  {
    this.handlers.push({spec:spec, fn:callback});
  }
  
  this.dispatchLines = function(lines)
  {
    lines.forEach(function(line) {
      This.handlers.forEach(function(handler) {
        if (handler.spec instanceof RegExp) {
          var m = handler.spec.exec(line);
          if (m) {
            if (m.length === 1)
              handler.fn(parseLine(line), line);
            else
              handler.fn.apply(this, Array.prototype.slice.call(m, 1));
          }
        }
      });
    });
  }
  
  this._stream = function(callback)
  {
    var cat = spawn('cat', filenames),
        sort_ = spawn('sort', ['-n', '-s']);

    cat.stdout.on('data', function(data) {sort_.stdin.write(data);});
    cat.on('exit', function(code) {sort_.stdin.end();});
    
    var buffer = '';
    sort_.stdout.on('data', function(data) {
      buffer += data;
      var lines = buffer.split('\n');
      buffer = lines.pop();
      if (lines.length > 0)
        This.dispatchLines(lines);
    });
    
    sort_.on('exit', function(code) {
      if (buffer.length > 0)
        This.dispatchLines([buffer]);
      callback(null);
    });
    
    cat.stderr.on('data', function(msg) {say(900, msg);});
    sort_.stderr.on('data', function(msg) {say(901, msg);});
  }
  
  asyncMod.call(this, ctor_callback);
}

var SessionStreamer = function(filenames, ctor_callback)
{
  var This = this,
      fileStreamer = null,
      resHandlers = [],
      reqHandlers = [],
      sessions = {};
  
  this.init = function(callback)
  {
    var s = new LogFilesStreamer(filenames, function(err, streamer) {
      fileStreamer = streamer;
      // request
      streamer.on(/ 489 sg/i, function(obj, line) {
        say(202, obj, line);
        var bsid = obj[2],
            url = obj[1]
            urlObj = mkUrlObj(url);
        var sessiontrack=obj[3];
        if(!sessiontrack || sessiontrack=='undefined') {
          if (bsid && bsid !== 'undefined') {
          
            var session = sessions[bsid] = sessions[bsid] || {bsid:bsid};
            reqHandlers.forEach(function(handler) {
              if (handler.re.exec(url)) {
                say(205, obj);
                handler.fn(obj.header.time, session, url, urlObj, obj, bsid);
              }
            });
          }
          return;
        }
      });
      
      // response
      streamer.on(/ 488 sg/i, function(obj, line) {
        var bsid = obj[0],
            url = obj[3],
            query = obj[4],
            sessiontrack=obj[1],
            urlObj = mkUrlObj(url + '?' + query);
        if(!sessiontrack || sessiontrack =='undefined') {
          if (bsid && bsid !== 'undefined') {
            var session = sessions[bsid] = sessions[bsid] || {bsid:bsid};
            resHandlers.forEach(function(handler) {
              if (handler.re.exec(url)) {
                say(205, obj);
                handler.fn(obj.header.time, session, url, urlObj, obj, bsid);
              }
            });
          }
          return;
        }
      });
      
//////eGift Request
      streamer.on(/495 dagwood/i, function(obj, line) {
        var bsid = obj[0],
            url = obj[3];
            urlObj = mkUrlObj();
        var sessiontrack=obj[1];
        if(!sessiontrack || sessiontrack=='undefined') {
          if (bsid && bsid !== 'undefined') {
            var session = sessions[bsid] = sessions[bsid] || {bsid:bsid};
            reqHandlers.forEach(function(handler) {
              if (handler.re.exec("/sg000/on/getData/egift")) {
                say(205, obj);
                handler.fn(obj.header.time, session, url, urlObj, obj, bsid);
              }
            });
          }
          return;
        }
      });

      streamer.on(/494 dagwood/i, function(obj, line) {
        var bsid = obj[0],
            url = obj[3];
            urlObj = mkUrlObj();
        var sessiontrack=obj[1];
        if(!sessiontrack || sessiontrack=='undefined') {
          if (bsid && bsid !== 'undefined') {
            var session = sessions[bsid] = sessions[bsid] || {bsid:bsid};
            resHandlers.forEach(function(handler) {
              if (handler.re.exec("/sg000/on/getData/egift")) {
                say(205, obj);
                handler.fn(obj.header.time, session, url, urlObj, obj, bsid);
              }
            });
          }
          return;
        }
      });

	  streamer.on(/496 dagwood/i, function(obj, line) {
        var bsid = obj[0],
            url = obj[2];
            urlObj = mkUrlObj();
        var sessiontrack=obj[1];
        if(!sessiontrack || sessiontrack=='undefined') {
          if (bsid && bsid !== 'undefined') {
            var session = sessions[bsid] = sessions[bsid] || {bsid:bsid};
            resHandlers.forEach(function(handler) {
              if (handler.re.exec("initialEgiftRes.url")) {
                say(205, obj);
                handler.fn(obj.header.time, session, url, urlObj, obj, bsid);
              }
            });
          }
          return;
        }
      });
//////

//////Num of Arts and Merchants
      streamer.on(/ 486 dagwood/i, function(obj, line) {
        var bsid = obj[0],
            url = obj[3],
            query = obj[4],
            urlObj = mkUrlObj(url + '?' + query);
        sessiontrack=obj[1];
        if(!sessiontrack || sessiontrack=='undefined') {
          if (bsid && bsid !== 'undefined') {
            var session = sessions[bsid] = sessions[bsid] || {bsid:bsid};
            resHandlers.forEach(function(handler) {
              if (handler.re.exec('Design.url')) {
                say(205, obj);
                handler.fn(obj.header.time, session, url, urlObj, obj, bsid);
              }
            });
          }
          return;
        }
      });
      streamer.on(/ 484 dagwood/i, function(obj, line) {
        var bsid = obj[0],
            url = obj[3],
            query = obj[4],
            sessiontrack=obj[1];
            urlObj = mkUrlObj(url + '?' + query);
        if(!sessiontrack || sessiontrack=='undefined') {
          if (bsid && bsid !== 'undefined') {
            var session = sessions[bsid] = sessions[bsid] || {bsid:bsid};
            resHandlers.forEach(function(handler) {
              if (handler.re.exec('Merchant.url')) {
                say(205, obj);
                handler.fn(obj.header.time, session, url, urlObj, obj, bsid);
              }
            });
          }
          return;
        }
      });
////////

      /****** Print Job Metrics *******/
      streamer.on(/ 498 dagwood/i, function(obj, line) {
        var bsid = obj[0],
            url = obj[3],
            query = obj[4],
            sessiontrack=obj[1],
            urlObj = mkUrlObj(url + '?' + query);
        if(!sessiontrack || sessiontrack == 'undefined') {
          if (bsid && bsid !== 'undefined') {
            var session = sessions[bsid] = sessions[bsid] || {bsid:bsid};
            reqHandlers.forEach(function(handler) {
              if (handler.re.exec('printdata.url')) {
                say(205, obj);
                handler.fn(obj.header.time, session, url, urlObj, obj, bsid);
              }
            });
          }
          return;
        }
      });

      streamer.on(/ 480 dagwoodPrintServer/i, function(obj, line) {
        var bsid = obj[0],
            url = 'http://example.com';
            urlObj = mkUrlObj();
        var sessiontrack=obj[1];
      if(!sessiontrack || sessiontrack=='undefined') {
        if (bsid && bsid !== 'undefined') {
          var session = sessions[bsid] = sessions[bsid] || {bsid:bsid};
          resHandlers.forEach(function(handler) {
              if (handler.re.exec('printInfo.url')) {
              say(205, obj);
              handler.fn(obj.header.time, session, url, urlObj, obj, bsid);
            }
          });
        }
        return;
      }
      });

      streamer.on(/ 479 dagwoodPrintServer/i, function(obj, line) {
        var bsid = obj[0],
            url = obj[2],
            query = obj[3],
            urlObj = mkUrlObj(url + '?' + query);
        var sessiontrack=obj[1];
      if(!sessiontrack || sessiontrack=='undefined') {
        if (bsid && bsid !== 'undefined') {
          var session = sessions[bsid] = sessions[bsid] || {bsid:bsid};
          resHandlers.forEach(function(handler) {
              if (handler.re.exec('printjob.url')) {
              say(205, obj);
              handler.fn(obj.header.time, session, url, urlObj, obj, bsid);
            }
          });
        }
        return;
      }
      });

      streamer.on(/ 478 dagwoodPrintServer/i, function(obj, line) {
        var bsid = obj[0],
            url = obj[2],
            query = obj[3],
            urlObj = mkUrlObj(url + '?' + query);
        var sessiontrack=obj[1];
      if(!sessiontrack || sessiontrack=='undefined') {
        if (bsid && bsid !== 'undefined') {
          var session = sessions[bsid] = sessions[bsid] || {bsid:bsid};
          resHandlers.forEach(function(handler) {
              if (handler.re.exec('printjob1.url')) {
              say(205, obj);
              handler.fn(obj.header.time, session, url, urlObj, obj, bsid);
            }
          });
        }
        return;
      }
      });


      streamer.on(/ 482 loki-server/i, function(obj, line) {
        var bsid = obj[0],
            url = obj[2],
            query = obj[3],
            urlObj = mkUrlObj(url + '?' + query);
        var sessiontrack=obj[1];
      if(!sessiontrack || sessiontrack=='undefined') {
        if (bsid && bsid !== 'undefined') {
          var session = sessions[bsid] = sessions[bsid] || {bsid:bsid};
          resHandlers.forEach(function(handler) {
              if (handler.re.exec('lokiprint.url')) {
              say(205, obj);
              handler.fn(obj.header.time, session, url, urlObj, obj, bsid);
            }
          });
        }
        return;
      }
      });

       streamer.on(/470 dagwood/i, function(obj, line) {
       
        var bsid = obj[0],
            url = obj[3];
            urlObj = mkUrlObj();
        var sessiontrack=obj[1];
        if(!sessiontrack || sessiontrack=='undefined') {
          if (bsid && bsid !== 'undefined') {
            var session = sessions[bsid] = sessions[bsid] || {bsid:bsid};
            resHandlers.forEach(function(handler) {
              if (handler.re.exec("personalizeInfo.url")) {
                say(205, obj);
                handler.fn(obj.header.time, session, url, urlObj, obj, bsid);
              }
            });
          }
          return;
        }
      });
      /***************************/

      // static file
      streamer.on(/ 487 sg/i, function(obj, line) {
        var bsid = obj[0],
            url = obj[3],
            query = obj[4],
            sessiontrack=obj[1];
            urlObj = urlParse.parse('http://example.com/' + url + '?' + query);
         if(!sessiontrack || sessiontrack=='undefined') {
          if (bsid && bsid !== 'undefined') {
            var session = sessions[bsid] = sessions[bsid] || {bsid:bsid};
            resHandlers.forEach(function(handler) {
              if (handler.re.exec(url)) {
                handler.fn(obj.header.time, session, url, urlObj, obj, bsid);
              }
            });
          }
          return;
        }
      });
      
      streamer.on(/ 488 dagwood/i, function(obj, line) {
        var bsid = obj[0],
            url = obj[3];
            urlObj = mkUrlObj(url );
        var sessiontrack=obj[1];
        if(!sessiontrack || sessiontrack == 'undefined') {
          if (bsid && bsid !== 'undefined') {
            var session = sessions[bsid] = sessions[bsid] || {bsid:bsid};
            resHandlers.forEach(function(handler) {
              if (handler.re.exec(url)) {
                say(205, obj);
                handler.fn(obj.header.time, session, url, urlObj, obj, bsid);
              }
            });
          }
          return;
        }
      });

      var messagesWithBsid = {
        'template':{id:239, mod:'sg', bsidFn:function(obj, line) {return {bsid:'', url:'', urlObj:{}}} },
        
        // App receiving an RPC request
        'sg239':{id:239, mod:'sg', bsidFn:function(obj, line) {
          return {
              bsid:'obj[0].params[0].params[0].bsid || obj[0].params[0].params[0]', 
              url:null, 
              urlObj:null,
              other:{
                  method:obj[0].method,
                  params:obj[0].params[0].params
              }
          }}
        }
      };
      
      This.__on = function(mod, id, normalHandler, sessionHandler)
      {
        var mapId = mod+id;
        streamer.on(RegExp(' '+id+' '+mod+',, '), function(obj, line) {
          if (typeof normalHandler === 'function') {
            normalHandler(obj, line);
          }
          
          if (typeof sessionHandler === 'function') {
            if (mapId in messagesWithBsid) {
              var msg_info = messagesWithBsid[mapId].bsidFn(obj, line),
                  bsid = msg_info.bsid,
                  url = msg_info.url,
                  urlObj = msg_info.urlObj;
              var session = sessions[bsid] = sessions[bsid] || {bsid:bsid};
              sessionHandler(obj.header.time, session, url, urlObj, obj, bsid, msg_info.other);
            }
          }
        });
      }
      
      callback(null, This);
    });
  }
  
  this._on = function(mod, id, normalHandler, sessionHandler)
  {
    return this.__on.apply(this, arguments);
  }
  
  this._onRes = function(reUrl, callback)
  {
    resHandlers.push({re:reUrl, fn:callback});
  }
  
  this._onReq = function(reUrl, callback)
  {
    reqHandlers.push({re:reUrl, fn:callback});
  }
  
  this._stream = function(callback)
  {
    // end
    fileStreamer.stream(function() {
      callback(null, sessions);
    });
  }
  
  asyncMod.call(this, ctor_callback);
}

var sgRe = function(start, mod, ids)
{
  var ret = start.slice();
  for (var i = 0; i < ids.length; ++i) {
    ret.push(RegExp(' ' + ids[i] + ' ' + mod + ',, '));
  }
  return ret;
}

// Constructor
//
// Signatures:
//   mod, [{ids:[ids], handler:fn}, ...]
//   {re:[RegExp, ...], handler:fn}, ...
var msgSet = function()
{
  var This = this,
      msgHandlers = [];       // [ {res:[/ /, / /], handler:function(){} } ]
  
  // construct via one mod name, and an Array of handlers:
  //   (mod, [{ids:[1,2,3], handler:function a(){}}, {ids:[8,9,10], handler:function b(){} }])
  var mod_ctor = function(mod, idHandlers)
  {
    idHandlers.forEach(function(h) {
      msgHandlers.push({res:sgRe([], mod, h.ids), handler:h.handler});
    });
  };

  // construct via one mod name, one id, and one handler
  //   (mod, id, handler)
  var one_handler_ctor = function(mod, id, handler)
  {
    msgHandlers.push({res:sgRe([], mod, [id]), handler:handler});
  };

  if (arguments.length === 2 && typeof arguments[0] === 'string') {
    var args = [arguments[0]];  // The mod
    args.push(arguments[1].slice());
    mod_ctor.apply(this, args);
  }
  else if (arguments.length === 3) {
    one_handler_ctor.apply(this, arguments);
  }

  this.register = function(fileStreamer)
  {
    msgHandlers.forEach(function(h) {
      h.res.forEach(function(re) {
        fileStreamer.on(re, function(obj, line) {
          h.handler.apply(this, arguments);
        });
      });
    });
  }

}

function mkUrlObj(str)
{
  var ret = urlParse.parse('http://example.com' + str);
  ret.queryObj = querystring.parse(ret.query);
  return ret;
}

function shallowItem(x)
{
  return x;
}

function deepItem(x)
{
  return clone(x, true);
}

function clone(x, deep)
{
  var item = deep? deepItem : shallowItem;
  
  if (x instanceof Array) {
    return x.slice();
  }
  else if (typeof x === 'object') {
    // Let the object clone itself, it it wants
    if (typeof x.clone === 'function') {
      return x.clone();
    }
    else {
      var y = {};
      for (var k in x) {
        y[k] = item(x[k]);
      }
      return y;
    }
  }
  return x;
}

var ThreadsStreamer = function(filenames, ctor_callback)
{
  var This = this,
      fileStreamer = null,
      threadCharacteristics = [],
      threads = {};
  
  this.init = function(callback)
  {
    var s = new LogFilesStreamer(filenames, function(err, streamer) {
      fileStreamer = streamer;

      callback(null, This);
    });
  }
  
  var mkTemplate = function(template)
  {
    if (typeof template === 'function')
      return template;
    else
      return function() {return clone(template || {}, true);}
  }
  
  this._on = function(name, modHandlers, template_, err_callback_)
  {
    var thread = threads[name] = [], 
        err_callback = err_callback_ || noop,
        template = mkTemplate(template_);
    
    modHandlers.forEach(function(modHandler) {
      var idHandlers = [
            // Thread start
            {ids:modHandler.idhStart.ids, 
              handler:function(obj, line) {
                var t = template();
                t.startTime = obj.header.time;
                t.startDate = new Date();
                t.startDate.setTime(obj.header.time);
                thread.unshift(t);
                thread[0].state = 'starting';
                modHandler.idhStart.handler(thread[0], obj, line);
                thread[0].state = 'processing';
              }},

            // Thread end
            {ids:modHandler.idhEnd.ids, 
              handler:function(obj, line) {
                if (thread.length < 1 || thread[0].state !== 'processing')
                  err_callback('notStarted', obj, line);
                else {
                  thread[0].state = 'closing';
                  modHandler.idhEnd.handler(thread[0], obj, line);
                  thread[0].state = 'closed';
                }
              }}
        ];

            // Normal intermediate messages
        if ('idhNormal' in modHandler) {
          idHandlers.push({
            ids:modHandler.idhNormal.ids, 
              handler:function(obj, line) {
                if (thread.length < 1 || thread[0].state !== 'processing')
                  err_callback('notStarted', obj, line);
                else
                  modHandler.idhNormal.handler(thread[0], obj, line);
          }});
        }

      //   mod, [{ids:[ids], handler:fn}, ...]
      threadCharacteristics.push(new msgSet(modHandler.mod, idHandlers));
    });
    
  }
  
  this._onOneStart = function(name, mod, id, handler, template_, err_callback_)
  {
    var thread = threads[name] = threads[name] || [], 
        err_callback = err_callback_ || noop,
        template = mkTemplate(template_);
    threadCharacteristics.push(new msgSet(mod, id, function(obj, line) {
      var t = template();
      t.startTime = obj.header.time;
      t.startDate = new Date();
      t.startDate.setTime(obj.header.time);
      thread.unshift(t);
      thread[0].state = 'starting';
      msgIds(thread[0], obj, line);
      handler(thread[0], obj, line);
      thread[0].state = 'processing';
    }));
  }
  
  this._onOneEnd = function(name, mod, id, handler, template_, err_callback_)
  {
    var thread = threads[name] = threads[name] || [], 
        err_callback = err_callback_ || noop,
        template = mkTemplate(template_);
    threadCharacteristics.push(new msgSet(mod, id, function(obj, line) {
      if (thread.length < 1 || thread[0].state !== 'processing')
        err_callback('notStarted', obj, line);
      else {
        thread[0].state = 'closing';
        msgIds(thread[0], obj, line);
        handler(thread[0], obj, line);
        thread[0].state = 'closed';
      }
    }));
  }
  
  this._onOneNormal = function(name, mod, id, handler, template_, err_callback_)
  {
    var thread = threads[name] = threads[name] || [], 
        err_callback = err_callback_ || noop,
        template = mkTemplate(template_);
    threadCharacteristics.push(new msgSet(mod, id, function(obj, line) {
      if (thread.length < 1 || thread[0].state !== 'processing')
        err_callback('notStarted', obj, line);
      else {
        msgIds(thread[0], obj, line);
        handler(thread[0], obj, line);
      }
    }));
  }
  
  var msgIds = function(thread, obj, line)
  {
    thread.ids.push([obj.header.id, dt(obj, thread.startTime)]);
  }
  
  this._dumpOneMod = function(name, mod, startIds, endIds, otherIds)
  {
    this._on(name,
      [{mod:mod,
          idhStart:{ids:startIds, 
            handler:function(thread, obj, line) {
              msgIds(thread, obj, line);
            }},
          idhEnd:{ids:endIds, 
            handler:function(thread, obj, line) {
              msgIds(thread, obj, line);
            }},
          idhNormal:{ids:otherIds, 
            handler:function(thread, obj, line) {
              msgIds(thread, obj, line);
            }}}
      ], 
      {ids:[]}    // template
    );
  }

  this._dumpOneModDebug = function(name, mod, startIds, endIds, otherIds)
  {
  
    function dump(id, msg, thread, obj, line)
    {
       say2(id, msg, obj.header.id, thread.ids);
//       say2(id, msg, thread, obj, line);
    }
    
    this._on(name,
      [{mod:mod,
          idhStart:{ids:startIds, 
            handler:function(thread, obj, line) {
              msgIds(thread, obj, line);
              dump(204, 'start', thread, obj, line);
            }},
          idhEnd:{ids:endIds, 
            handler:function(thread, obj, line) {
              msgIds(thread, obj, line);
              dump(206, 'end', thread, obj, line);
            }},
          idhNormal:{ids:otherIds, 
            handler:function(thread, obj, line) {
              msgIds(thread, obj, line);
              dump(207, 'normal', thread, obj, line);
            }}}
      ], 
      {ids:[]}    // template
    );
  }

  this._stream = function(callback)
  {
    // Register handlers to the file streamer
    threadCharacteristics.forEach(function(threadChar) {
      threadChar.register(fileStreamer);
    });
    
    say(203, fileStreamer);

    // end
    fileStreamer.stream(function() {
      callback(null, threads);
    });
  }
  
  asyncMod.call(this, ctor_callback);
}

var latestLogs = function(num_,logFilePath,  callback)
{
  
  try
  {
    stats = fs.lstatSync(logFilePath);
    logFilePath=logFilePath+'/';
  }
  catch (e)
  {
    logFilePath="/var/log/sgSay/runs/";
  }

   
  var num = arguments.length > 1 ? num_ : 3,
      startDir = process.cwd();
  
  process.chdir(logFilePath);
  exec('find -type f | cut -d/ -f2- | sort -n --reverse | head -n ' + num, function(err, logFilesStdout, logFilesStderr) {
    say(801, err, logFilesStdout, logFilesStderr);
    if (err) callback(err);
    else {
      var logFiles = logFilesStdout.split('\n')
        .filter(function(x) {return x.length > 0;})
        .map(function(x){return logFilePath+x;});
        
      say(201, logFiles);

      process.chdir(startDir);
      callback(null, logFiles);
    }
  });
}

var logs = function(root, callback)
{
  var logFilePath = root,
      startDir = process.cwd();
  
  process.chdir(logFilePath);
  exec('find -type f', function(err, logFilesStdout, logFilesStderr) {
    say(800, err, logFilesStdout, logFilesStderr);
    if (err) callback(err);
    else {
      var logFiles = logFilesStdout.split('\n')
        .filter(function(x) {return x.length > 0;})
        .map(function(x){return logFilePath+x;});
        
      say(209, logFiles);

      process.chdir(startDir);
      callback(null, logFiles);
    }
  });
}

/**@ignore*/
exports.isMatch = function(x, template)
{
  for (var k in template) {
    if (x[k] != template[k])
      return false;
  }
  return true;
}


/**@ignore*/
exports.SessionStreamer = SessionStreamer;

/**@ignore*/
exports.ThreadsStreamer = ThreadsStreamer;

/**@ignore*/
exports.LogFilesStreamer = LogFilesStreamer;

/**@ignore*/
exports.latestLogs = latestLogs;

/**@ignore*/
exports.logs = logs;

